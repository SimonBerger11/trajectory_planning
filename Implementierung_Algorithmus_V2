import math
from pylab import *
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np
import time
import Analyse_Map

class Node:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
        self.parent = None
        self.costStart = 0
        self.minimumCost = 0
        self.sum = 0
        
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y and self.z == other.z
    
    #def __str__(self):
    #    return str(self.x) + " " + str(self.y)+ " " + str(self.minimumCost)

fig = plt.figure()
ax = fig.add_subplot(111)

        
start_point = (5,5,0)
end_point = (14,10,0)
scatter(start_point[0], start_point[1], color = "green", s = 80)
scatter(end_point[0], end_point[1], color = "green", s = 80)

#way = [(0,0,0), (1,0,0),(2,0,0),(3,0,0)]



way = createLines()

way_x = []
way_y = []
for w in way:
    way_x.append(w[0])
    way_y.append(w[1])

collision = []


def astar(start, end, middle_way):
    open_list = []      # Alle noch zu untersuchenden nodes
    closed_list = []    # Alle schon untersuchten nodes

    start_node = Node(start[0], start[1], start[2])
    
    end_node = Node(end[0], end[1], end[2])

    open_list.append(start_node)
    
    cnt = 0
    while 1:
        # Suche des n√§chsten current_node mit der kleinsten Gesamtsumme
        current_node = open_list[0]
        current_index = 0



        for index, item in enumerate(middle_way):
            if item.sum < current_node.sum:           
                current_node = item
                current_index = index
        

        open_list.pop(current_index)
        closed_list.append(current_node)

        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                ax.scatter(current.x, current.y, color = "green", s = 80)
                path.append((current.x, current.y, current.z))
                current = current.parent
            return path

        
        # Update middle_way
        for count, child in enumerate(middle_way):
            flag = False
            for closed in closed_list:
                if child.x == closed.x and child.y == closed.y:
                    flag = True
                    continue
            
            
            child.costStart = child.costStart + math.sqrt((child.x - end_p[0]) ** 2 + (child.x - end_p[1]) ** 2 + (w[2] - end_p[2]) ** 2)
        

            for open in open_list:
                if child.x == open.x and child.y == open.y and child.costStart >= open.costStart:
                    flag = True
                    break

            if flag == True:
                continue

            #child.minimumCost = math.sqrt((child.x - end_node.x) ** 2 + (child.y - end_node.y) ** 2 + (child.z - end_node.z) ** 2)
            child.sum = child.costStart + child.minimumCost
            
            for open_node in open_list:
                if child == open_node and child.costStart > open_node.costStart:
                    continue

            open_list.append(child)
    return None

def init_way (way_t, end_p, start_p):
    mw = [] 
    for w in way_t:
        node = Node(w[0],w[1], w[2])
        node.minimumCost = math.sqrt((w[0] - end_p[0]) ** 2 + (w[1] - end_p[1]) ** 2 + (w[2] - end_p[2]) ** 2)
        #node.costStart = math.sqrt((w[0] - start_p[0]) ** 2 + (w[1] - start_p[1]) ** 2 + (w[2] - start_p[2]) ** 2)
        mw.append(node)
    
    return mw 



way_node = init_way (way, end_point, start_point)



result = astar(start_point,end_point,way_node)






plt.show()        


